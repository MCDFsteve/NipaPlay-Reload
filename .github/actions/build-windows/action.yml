name: 'Build Windows Package'
description: '构建 Windows 应用并生成 ZIP 和安装程序'
inputs:
  app-version:
    description: '应用版本号'
    required: true
outputs:
  zip-path:
    description: '生成的 ZIP 文件路径'
    value: ${{ steps.build.outputs.zip_path }}
  installer-path:
    description: '生成的安装程序路径'
    value: ${{ steps.installer.outputs.installer_path }}
runs:
  using: 'composite'
  steps:
    - name: Setup Chinese Font for Windows
      shell: pwsh
      run: |
        Write-Host "Setting up Chinese font for Windows build..."
        cd windows
        if (Test-Path "setup_font.bat") {
          Write-Host "Executing setup_font.bat..."
          cmd /c "setup_font.bat"
          if ($LASTEXITCODE -ne 0) {
            Write-Host "Warning: Font setup failed with exit code $LASTEXITCODE"
          } else {
            Write-Host "Font setup completed successfully"
          }
        } else {
          Write-Host "Warning: setup_font.bat not found, skipping font setup"
        }
        cd ..
    
    - name: Build Web and copy assets
      shell: bash
      run: |
        chmod +x build_and_copy_web.sh
        ./build_and_copy_web.sh

    - name: Download full libmpv package
      shell: pwsh
      run: |
        $customUrl = $env:LIBMPV_DOWNLOAD_URL
        $assetPattern = $env:LIBMPV_ASSET_PATTERN
        if ([string]::IsNullOrEmpty($assetPattern)) {
          $assetPattern = "mpv-dev-x86_64-v3.*\.7z"
        }
        choco install 7zip -y --no-progress
        $sevenZip = $null
        if ($env:ProgramFiles) {
          $candidate = Join-Path $env:ProgramFiles "7-Zip\7z.exe"
          if (Test-Path $candidate) {
            $sevenZip = $candidate
          }
        }
        if (-not $sevenZip -and ${env:ProgramFiles(x86)}) {
          $candidate = Join-Path ${env:ProgramFiles(x86)} "7-Zip\7z.exe"
          if (Test-Path $candidate) {
            $sevenZip = $candidate
          }
        }
        if (-not $sevenZip) {
          throw "未找到 7z.exe，请确保 7zip 安装成功"
        }
        $packagePath = "windows\libmpv-package.7z"
        $extractDir = "windows\libmpv-package"
        Remove-Item $packagePath -Force -ErrorAction SilentlyContinue
        Remove-Item $extractDir -Recurse -Force -ErrorAction SilentlyContinue
        New-Item -Path $extractDir -ItemType Directory -Force | Out-Null
        if ([string]::IsNullOrEmpty($customUrl)) {
          $releaseApi = "https://api.github.com/repos/shinchiro/mpv-winbuild-cmake/releases/latest"
          $headers = @{
            "User-Agent" = "NipaPlay-Build"
            "Accept"    = "application/vnd.github+json"
          }
          if ($env:GITHUB_TOKEN) {
            $headers["Authorization"] = "Bearer $($env:GITHUB_TOKEN)"
          }
          try {
            $release = Invoke-RestMethod -Uri $releaseApi -Headers $headers -UseBasicParsing
          } catch {
            throw "获取 mpv 最新版本信息失败：$($_.Exception.Message)"
          }
          $asset = $release.assets | Where-Object { $_.name -match $assetPattern } | Select-Object -First 1
          if (-not $asset) {
            $fallbackPattern = "mpv-dev-x86_64.*\.7z"
            $asset = $release.assets | Where-Object { $_.name -match $fallbackPattern } | Select-Object -First 1
          }
          if (-not $asset) {
            $fallbackPattern = "libmpv-shared-x86_64.*\.7z"
            $asset = $release.assets | Where-Object { $_.name -match $fallbackPattern } | Select-Object -First 1
          }
          if (-not $asset) {
            throw "未在 mpv 最新 release 中找到匹配的 libmpv 包"
          }
          $customUrl = $asset.browser_download_url
          Write-Host "选用 libmpv 资源：$($asset.name)"
        } else {
          Write-Host "使用自定义 libmpv 下载地址：$customUrl"
        }
        Write-Host "开始下载 libmpv 包：$customUrl"
        Invoke-WebRequest -Uri $customUrl -OutFile $packagePath -UseBasicParsing
        & $sevenZip x $packagePath "-o$extractDir" -y | Out-Null
        $dll = Get-ChildItem -Path $extractDir -Recurse -Filter "libmpv-2.dll" | Select-Object -First 1
        if (-not $dll) {
          throw "libmpv 包中未找到 libmpv-2.dll"
        }
        Copy-Item -Path $dll.FullName -Destination "windows\libmpv-2.dll" -Force
        Remove-Item $packagePath -Force -ErrorAction SilentlyContinue
        Write-Host "libmpv-2.dll 已下载并可用于后续打包"
    
    - name: Build Windows
      id: build
      shell: pwsh
      run: |
        flutter build windows --release
        $arch = "x64"
        $version = "${{ inputs.app-version }}"
        $DestDir = "build\windows\NipaPlay_${version}_Windows_x64"
        $SrcDir = "build\windows\x64\runner\Release"
        $CustomLib = "windows\libmpv-2.dll"
        if (!(Test-Path $SrcDir)) {
          throw "Windows 构建输出目录不存在：$SrcDir"
        }
        if (!(Test-Path $CustomLib)) {
          throw "未找到内置的完整版 libmpv：$CustomLib"
        }
        Copy-Item -Path $CustomLib -Destination "$SrcDir\libmpv-2.dll" -Force
        Write-Host "已将构建输出中的 libmpv-2.dll 替换为完整版"
        New-Item -Path $DestDir -ItemType Directory -Force
        Copy-Item -Path "$SrcDir\*" -Destination $DestDir -Recurse -Force
        Copy-Item -Path "windows\*.dll" -Destination $DestDir -Force
        $zipPath = "build\windows\NipaPlay_${version}_Windows_x64.zip"
        Compress-Archive -Path $DestDir -DestinationPath $zipPath -Force
        echo "zip_path=$zipPath" >> $env:GITHUB_OUTPUT

    - name: Prepare Windows installer assets
      shell: pwsh
      run: |
        # Install ImageMagick for image processing
        choco install imagemagick -y
        
        $arch = "x64"
        $version = "${{ inputs.app-version }}"
        $BuildDir = "build\windows\x64\runner\Release"
        
        # Create installer assets directory
        New-Item -Path "installer_assets" -ItemType Directory -Force
        
        # Copy installer script and assets to build directory
        Copy-Item -Path "windows\nipaplay_installer.nsi" -Destination "$BuildDir\"
        Copy-Item -Path "installer_assets\*" -Destination "$BuildDir\" -Recurse -Force
        Copy-Item -Path "LICENSE" -Destination "$BuildDir\" -ErrorAction SilentlyContinue

    - name: Create Windows installer with NSIS
      id: installer
      shell: pwsh
      run: |
        # Force reinstall NSIS to ensure clean state
        choco install nsis --force --yes
        
        $arch = "x64"
        $version = "${{ inputs.app-version }}"
        $BuildDir = "build\windows\x64\runner\Release"
        
        # Read NSIS script with proper encoding
        $nsiContent = Get-Content "$BuildDir\nipaplay_installer.nsi" -Raw -Encoding UTF8
        
        # Ensure version is in 4-part format for NSIS (X.Y.Z.W)
        $versionParts = $version.Split('.')
        if ($versionParts.Length -eq 3) {
          $nsiVersion = "${version}.0"
        } elseif ($versionParts.Length -eq 4) {
          $nsiVersion = $version
        } else {
          $nsiVersion = "1.0.0.0"
        }
        Write-Host "Using version: $version, NSIS version: $nsiVersion"
        
        # Update version information with proper escaping
        $nsiContent = $nsiContent -replace 'VIProductVersion "1\.0\.0\.0"', "VIProductVersion `"${nsiVersion}`""
        $nsiContent = $nsiContent -replace 'VIAddVersionKey "FileVersion" "1\.0\.0\.0"', "VIAddVersionKey `"FileVersion`" `"${nsiVersion}`""
        $nsiContent = $nsiContent -replace 'VIAddVersionKey "ProductVersion" "1\.0\.0\.0"', "VIAddVersionKey `"ProductVersion`" `"${nsiVersion}`""
        
        # Update output filename
        $nsiContent = $nsiContent -replace 'OutFile "NipaPlay_Setup\.exe"', "OutFile `"NipaPlay_${version}_Windows_x64_Setup.exe`""
        
        # Write file with UTF8 BOM to ensure proper encoding for NSIS
        $utf8BOM = New-Object System.Text.UTF8Encoding $true
        [System.IO.File]::WriteAllText("$BuildDir\nipaplay_installer.nsi", $nsiContent, $utf8BOM)
        
        # Download FileAssociation plugin for NSIS with multiple fallback URLs
        $pluginUrls = @(
          "https://nsis.sourceforge.io/mediawiki/images/7/7f/FileAssociation.nsh",
          "https://raw.githubusercontent.com/NSIS-Dev/Documentation/master/Reference/FileAssociation.nsh",
          "https://raw.githubusercontent.com/nsis-dev/nsis/master/Contrib/FileAssociation/FileAssociation.nsh"
        )
        
        $pluginPath = "$BuildDir\FileAssociation.nsh"
        $downloadSuccess = $false
        
        foreach ($url in $pluginUrls) {
          try {
            Write-Host "Attempting to download FileAssociation.nsh from $url"
            Invoke-WebRequest -Uri $url -OutFile $pluginPath -UseBasicParsing -ErrorAction Stop
            if (Test-Path $pluginPath) {
              $content = Get-Content $pluginPath -Raw
              if ($content -match "FileAssociation") {
                $downloadSuccess = $true
                Write-Host "Successfully downloaded FileAssociation.nsh from $url"
                break
              }
            }
          } catch {
            Write-Host "Failed to download from $url"
            continue
          }
        }
        
        if (-not $downloadSuccess) {
          Write-Host "All download attempts failed, creating basic FileAssociation.nsh"
          $lines = @()
          $lines += "!ifndef FileAssociation_INCLUDED"
          $lines += "!define FileAssociation_INCLUDED"
          $lines += ""
          $lines += "!macro RegisterExtension executable extension description"
          $lines += "  WriteRegStr HKCR `".`${extension}`" `"`" `"`${description}`""
          $lines += "  WriteRegStr HKCR `"`${description}`" `"`" `"`${description}`""
          $lines += "  WriteRegStr HKCR `"`${description}\DefaultIcon`" `"`" `"`${executable},0`""
          $lines += "  WriteRegStr HKCR `"`${description}\shell`" `"`" `"open`""
          $lines += "  WriteRegStr HKCR `"`${description}\shell\open`" `"`" `"`""
          $lines += "  WriteRegStr HKCR `"`${description}\shell\open\command`" `"`" '`"`${executable}`" `"%1`"'"
          $lines += "!macroend"
          $lines += ""
          $lines += "!macro UnRegisterExtension extension description"
          $lines += "  DeleteRegKey HKCR `".`${extension}`""
          $lines += "  DeleteRegKey HKCR `"`${description}`""
          $lines += "!macroend"
          $lines += ""
          $lines += "!endif # !FileAssociation_INCLUDED"
          Set-Content -Path $pluginPath -Value ($lines -join "`r`n") -Encoding UTF8
        }
        
        # Ensure NSIS can find the plugin
        $nsisIncludeDir = "C:\\Program Files (x86)\NSIS\Include"
        if (-not (Test-Path $nsisIncludeDir)) {
          New-Item -ItemType Directory -Force -Path $nsisIncludeDir
        }
        Copy-Item $pluginPath $nsisIncludeDir -Force
        
        # Compile installer with NSIS
        Push-Location $BuildDir
        $nsisPath = "C:\\Program Files (x86)\NSIS\makensis.exe"
        if (!(Test-Path $nsisPath)) {
          throw "NSIS compiler not found at $nsisPath"
        }
        
        Write-Host "Compiling installer with NSIS..."
        & $nsisPath "/V4" "nipaplay_installer.nsi"
        $exitCode = $LASTEXITCODE
        Pop-Location
        
        if ($exitCode -ne 0) {
          throw "NSIS compilation failed with exit code $exitCode"
        }
        
        # Move and verify installer
        $installerName = "NipaPlay_${version}_Windows_x64_Setup.exe"
        $installerPath = "$BuildDir\$installerName"
        $finalPath = "build\windows\$installerName"
        
        if (!(Test-Path $installerPath)) {
          throw "Installer file was not created: $installerPath"
        }
        
        Move-Item $installerPath "build\windows\" -Force
        
        if (!(Test-Path $finalPath)) {
          throw "Failed to move installer to final location: $finalPath"
        }
        
        Write-Host "NSIS installer created successfully at: $finalPath"
        echo "installer_path=$finalPath" >> $env:GITHUB_OUTPUT

    - name: List Windows build artifacts
      shell: pwsh
      run: |
        Write-Host "=== Windows Build Artifacts ==="
        Get-ChildItem "build\windows\" -File | ForEach-Object {
          $sizeKB = [math]::Round($_.Length / 1KB, 2)
          Write-Host "$($_.Name) - ${sizeKB} KB"
        }
